---
layout: post
title: "MQTT: Análisis Integral de Infraestructuras IoT: Implementación de Protocolos MQTT, Adaptaciones MQTT-SN y Arquitecturas Basadas en PKI."
date: 2026-1-23
---

## 1. El paradigma IoT y la Evoluación de la Conectividad

La transformación de la infraestructura global de información ha seguido una trayectoria de expansión exponencial, no solo en términos de volumen de datos, sino fundamentalmente en la capilaridad y naturaleza de los nodos conectados. Para contextualizar la implementación técnica de protocolos como MQTT (**Message Queuing Telemetry Transport**), es imperativo diseccionar primero la estratificación actual de Internet, la cual ha evolucionado desde una red centrada en el cómputo hacia una matriz omnipresente de sensórica distribuida.

### 1.1 *Core Internet*, *Fringe Internet* y *Internet of Things*

El "Core Internet" representa la génesis de la red. Históricamente, esta capa engloba lo que coloquialmente denominamos "lo de toda la vida": servidores de alto rendimiento, mainframes bancarios, enrutadores troncales y ordenadores de escritorio ("ordenadores tochos").

La expansión hacia el "Fringe Internet" o Internet del Borde marcó la transición hacia la movilidad personal. Aquí encontramos dispositivos como ordenadores portátiles, tablets y, fundamentalmente, smartphones.

La capa más exterior y actual es el Internet de las Cosas (IoT). En este estrato, la red trasciende la interacción humana directa para conectar "cosas": sensores ambientales, actuadores industriales, vehículos, electrodomésticos y microcontroladores integrados.

![IoT](/img/MQTT_1.png)

## 2. Protocolo MQTT

El protocolo MQTT, estandarizado por el consorcio OASIS, se erige como la solución de facto para la comunicación en la capa IoT. Diseñado originalmente para monitorear oleoductos a través de conexiones satelitales costosas e inestables, su filosofía de diseño se centra en el minimalismo: cada bit cuenta.

MQTT opera en la Capa de Aplicación (**Capa 7 del modelo OSI**), pero se sustenta sobre la pila TCP/IP (**Capas 3 y 4**). Al funcionar sobre TCP (*Transmission Control Protocol*), MQTT hereda la garantía de entrega ordenada de paquetes y la corrección de errores. Esto es crucial: el protocolo de aplicación no necesita reinventar la rueda para asegurar que los bytes lleguen en orden. Sin embargo, esto implica el costo del establecimiento de conexión (handshake de tres vías), lo cual puede ser pesado para dispositivos muy limitados que despiertan, envían un dato y vuelven a dormir.

### 2.1 Paradigma Publicación - Suscripción

A diferencia del modelo Cliente-Servidor de la web (donde el cliente solicita y espera, bloqueando recursos), MQTT utiliza un modelo asíncrono y desacoplado:

- Desacoplamiento Espacial: El emisor (sensor) y el receptor (aplicación móvil) no necesitan conocer sus direcciones IP mutuamente. Solo necesitan conocer al intermediario.
- Desacoplamiento Temporal: El Broker puede almacenar mensajes para clientes desconectados temporalmente.
- Desacoplamiento de Sincronización: Las operaciones no bloquean la ejecución del proceso principal.

### 2.2 Actores en MQTT

MQTT usa dos tipos de actores con responsabilidades claramente difeerenciadas:
- **Cliente**: Generador/ Consumidor de datos. Es el dispositivo final (sensor de temperatura, bombilla inteligente). Inicia la conexión TCP hacia el servidor. Publica información cuando ocurre un evento o se suscribe para recibir comandos.
- **Broker**/**Servidor**: Enrutador de mensajes. Es el corazón de la topología en estrella. Recibe todos los mensajes de los clientes, filtra por temas (topics) y distribuye a los suscriptores. Una característica crítica es que no guarda datos para sí mismo (salvo retención temporal de mensajes QoS > 0 o retenidos); su función es puramente logística.

### 2.3 Sesión MQTT

La comunicación en MQTT es persistente y orientada a estados, siguiendo un ciclo de vida riguroso.

Antes de intercambiar cualquier dato útil, se debe establecer una sesión mediante el paquete CONNECT. Este paquete es denso en información de control:   
- ***ClientId***: La "matrícula" del dispositivo. Debe ser única en el Broker.
- ***Clean Session Flag***: Determina si el Broker debe recordar al cliente. Si es False, el Broker guardará las suscripciones y los mensajes no entregados mientras el cliente estuvo desconectado (Persistencia).
- ***KeepAlive***: Un temporizador de "latido". Si el cliente no envía datos en este periodo, el Broker asume que la conexión TCP murió y cierra el socket. Esto evita conexiones "zombis".
- **Credenciales**: Usuario y contraseña para autenticación básica.
- ***Last Will***: Definición proactiva de un mensaje de "muerte".

La respuesta del servidor es un CONNACK (Connection Acknowledge), que contiene un código de retorno indicando éxito o la razón del rechazo.

### 2.4 Publicación MQTT

**Publicación**: Cuando un sensor tiene un dato (ej: temperatura: 32.5), genera un paquete PUBLISH. Este contiene:
- Topic Name: La dirección lógica del mensaje (ej: topic/1).
- Payload: La carga útil. MQTT es agnóstico al contenido (binario, texto, JSON).
- QoS Level: La calidad de servicio deseada para este mensaje específico.

### 2.5 Suscripción MQTT

Para recibir datos, un cliente no "pide" información, sino que declara su interés mediante un paquete SUBSCRIBE.   
- El cliente envía una lista de temas y el nivel de QoS máximo que puede procesar.
- El Broker confirma con un SUBACK.
- A partir de este momento, cualquier PUBLISH que coincida con los criterios será retransmitido al cliente por el Broker.

Para cesar la recepción, se utiliza UNSUBSCRIBE, confirmado por UNSUBACK, liberando recursos en el Broker.

### 2.6 QoS en MQTT

El protocolo permite negociar el equilibrio entre fiabilidad y ancho de banda mediante tres niveles de QoS. La elección correcta de QoS es crítica para el diseño del sistema.

![QoS](/img/MQTT_2.png)

#### QoS 0: *At most once*
- El mensaje se envía una sola vez. No hay confirmación de recepción.
- Fiabilidad baja. Si el paquete se pierde en la red o el Broker está saturado, el mensaje se pierde definitivamente.
- Datos de sensores de alta frecuencia (ej: acelerómetro a 10Hz) o lecturas ambientales periódicas donde perder una muestra no afecta la tendencia general. Es el más eficiente en energía.

#### QoS 1: *At least once*
- El emisor guarda el mensaje hasta recibir un acuse de recibo (PUBACK). Si el temporizador expira sin confirmación, reenvía el mensaje con un flag de duplicado (DUP).
- Garantiza que el mensaje llega, pero puede llegar múltiples veces (si el PUBACK se pierde). La aplicación receptora debe ser idempotente (capaz de manejar duplicados sin error).
- La mayoría de los casos de uso en IoT donde la entrega es importante, como estados de interruptores o alarmas no críticas. Es el estándar de la industria para fiabilidad razonable.   

#### QoS 2: *Exactly once*
- El nivel más sofisticado, diseñado para evitar duplicados a toda costa. Implica un handshake de cuatro vías:
- Emisor envía PUBLISH.
- Receptor responde PUBREC (Received) y reserva el identificador.
- Emisor recibe confirmación, envía PUBREL (Release) y descarta el mensaje.
- Receptor recibe orden de liberar, procesa el mensaje hacia la aplicación y responde PUBCOMP (Complete).
- Sistemas críticos transaccionales (pagos, contadores de stock, comandos médicos) donde un duplicado sería catastrófico.
- Es el más lento y el que más ancho de banda consume.

## 2.7 *Last Will*

El "Testamento" es una característica de seguridad pasiva crucial para detectar fallos. Al conectarse, el cliente configura un mensaje LWT en el Broker.

Si el cliente se desconecta graciosamente (enviando DISCONNECT), el testamento se borra. Pero si la conexión se rompe abruptamente (pérdida de cobertura, batería agotada), el Broker detecta la ausencia (por el KeepAlive) y publica automáticamente el mensaje LWT en el tema especificado, permitiendo así que otros dispositivos sepan instantáneamente si un sensor ha caído.

## 3. PKI y Cifrado TLS
Para asegurar el canal, implementamos TLS (*Transport Layer Security*). Esto requiere una jerarquía de confianza basada en certificados X.509. En el taller realizado, actuamos como nuestra propia Autoridad de Certificación (CA).

De forma esquemática, a continuación en las siguientes figuras se muestran los comandos necesarios para la correcta configuración de MQTT.

#### Instalación básica

![Instalación básica](/img/MQTT_3.png)

#### Seguridad PKI (TLS)

![Seguridad PKI](/img/MQTT_4.png)

#### Configuración Broker

![Configuración Broker](/img/MQTT_5.png)

### Cliente MQTTX

![Cliente MQTTX](/img/MQTT_6.png)

## 4. Implementación práctica del entorno y taller de prueba

Basado en la experiencia documentada , se procede a la instalación y configuración de un entorno de producción simulado.

### 4.1 Instalación y Preparación del Sistema

Se utiliza un entorno Linux (basado en Debian/Ubuntu), lo cual es estándar para servidores IoT.
- `sudo apt update` asegura que tenemos las últimas versiones.
- `sudo apt install mosquitto`. Mosquitto es el broker open-source más popular por su ligereza y cumplimiento del estándar.
- `sudo apt install mosquitto-clients`. Provee las utilidades de línea de comandos *mosquitto_pub* y *mosquitto_sub* para pruebas.

### 4.2 Configuración Avanzada de MQTT

Por defecto, Mosquitto es básico. La edición del archivo */etc/mosquitto/mosquitto.conf* es necesaria para habilitar seguridad y múltiples puertos.

Se configura una arquitectura de doble escucha (Dual Listener) para soportar legado y seguridad moderna:

```
# Habilitar configuración por listener (necesario desde v1.5)
per_listener_settings true

# --- LISTENER 1: Puerto Estándar (Inseguro) ---
# Útil para depuración local o dispositivos legacy en red aislada
listener 1883
allow_anonymous true  # Permitir conexión sin usuario/pass (solo para pruebas)

# --- LISTENER 2: Puerto Seguro (MQTTS) ---
# Estándar para tráfico de producción sobre TLS
listener 8883
# Rutas a la PKI generada en el paso 4
cafile /etc/mosquitto/certs/ca.crt
certfile /etc/mosquitto/certs/server.crt
keyfile /etc/mosquitto/certs/server.key
# Configuración de TLS
tls_version tlsv1.2
require_certificate false # true si quisiéramos autenticación mutua (mTLS)
```

**Nota sobre Permisos**: Es vital que el usuario *mosquitto* tenga permisos de lectura sobre la carpeta de certificados, o el servicio fallará al arrancar.   

Para aplicar los cambios realizados: `systemctl restart mosquitto`

### 4.3 Herramientas de Diagnóstico
5.3. Herramientas de Diagnóstico
Para la validación se utilizaron dos herramientas clave :   
- MQTTX: Un cliente gráfico moderno que permite gestionar conexiones, publicar en múltiples temas y visualizar el flujo de datos de manera estructurada.
- Wireshark: Analizador de paquetes de red. Su uso es educativo y de auditoría: permite capturar el tráfico en el puerto 1883 para demostrar que los datos viajan en texto plano (se pueden leer los payloads) y contrastarlo con el puerto 8883, donde solo se verá basura cifrada (TLS).

## 5. Análisis de datos y resultados en el taller
Durante la fase experimental del taller , se capturaron e inyectaron diversos mensajes para probar la teoría de QoS y la estructura de tópicos. A continuación, se presenta un análisis detallado de los datos observados y las implicaciones de diseño que revelan.

| Tópico | Valor | QoS | Interpretación y justificación |
| :--- | :--- | :--- | :--- |
| **brightness/1** | 7 | 0 | Telemetría de Sensor: Lectura de luminosidad. Se usa QoS 0 porque es un dato continuo; si se pierde una muestra, llegará otra en milisegundos. Se prioriza la baja latencia y el mínimo consumo de red. |
| **temperature/1** | 25 | N/A | Telemetría Ambiental: Lectura estándar. Probablemente QoS 0 por defecto. Indica una temperatura confortable de 25°C. |
| **Smartbulb-brightness/2** | 2 | 1 | Estado de Actuador: Feedback de una bombilla inteligente. Se usa QoS 1 ("Al menos una vez") para asegurar que el controlador central se entere del nuevo estado. Es preferible recibir el dato dos veces que no saber que la luz cambió. |
| **temperatura/2** | 20 | 2 | Dato Crítico/Anómalo: El uso de QoS 2 ("Exactamente una vez") para temperatura es inusual. Podría indicar un sensor en un proceso industrial delicado (ej: fabricación de medicinas) donde una lectura duplicada podría disparar erróneamente una lógica de compensación o alarma acumulativa. O bien, es una prueba académica de la capacidad del protocolo. |
| **on/1** | 1 | 1 | Comando Simple: Encender dispositivo 1. QoS 1 asegura que la orden llega. Si llega dos veces, encender una luz ya encendida no tiene efecto negativo (idempotencia). |
| **on/2** | 0 | 2 | Comando Crítico: Apagar dispositivo 2. El uso de QoS 2 sugiere que este dispositivo no tolera comandos duplicados, o es un sistema de toggling (conmutación) donde recibir la orden dos veces revertiría el estado no deseado. |
| **intensity/2** | N/A	| 1 y 2 | Se observaron variantes con ambos niveles de QoS, indicando pruebas de fiabilidad sobre el control de intensidad de iluminación.

El experimento confirma que la elección de QoS no es trivial y depende de la semántica de la aplicación:
- QoS 0 domina en la monitorización pasiva.
- QoS 1 es el estándar para control donde la idempotencia es posible (ej: set_power(ON)).
- QoS 2 se reserva para operaciones lógicas complejas o transacciones donde la duplicidad corrompe el estado del sistema.

## 6. Conclusiones
El diseño de sistemas IoT es un ejercicio constante de balance. MQTT ofrece las herramientas (QoS, LWT, KeepAlive) para ajustar este balance, permitiendo desde sensores desechables (QoS 0, UDP) hasta controles industriales críticos (QoS 2, TCP).

Por otro lado, para alcanzar la escala de "trillones" de nodos predicha en la capa IoT, la dependencia de TCP debe romperse en el "último metro". MQTT-SN sobre UDP, con sus mecanismos de Sleep y Topic IDs, es esencial para la viabilidad de redes de sensores masivas alimentadas por batería.

La simplicidad de MQTT es su mayor fortaleza y su mayor riesgo. La implementación de TLS/SSL no debe ser una idea tardía. Aunque añade sobrecarga computacional, la protección de la infraestructura crítica contra espionaje y manipulación es innegociable. La gestión propia de una CA, como se demostró, es una habilidad fundamental para el administrador de sistemas IoT.

---
**Escrito por Daniel Barbeyto Torres**, *apoyado de herramientas de modelos de lenguaje para la redacción.*